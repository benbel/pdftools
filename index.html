<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Outils PDF</title>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/tesseract.js@5.0.4/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: monospace;
            font-size: 16px;
            line-height: 1.6;
            background: #fcfcfc;
            color: #111;
            padding: 2rem;
            max-width: 800px;
            margin: 0 auto;
        }
        h1 { font-size: 1.5rem; margin-bottom: 0.5rem; }
        p.sub { color: #666; margin-bottom: 2rem; }
        .tabs { display: flex; gap: 1rem; margin-bottom: 2rem; flex-wrap: wrap; }
        .tab { cursor: pointer; padding: 0.25rem 0; border-bottom: 2px solid transparent; }
        .tab:hover { border-color: #999; }
        .tab.active { border-color: #111; }
        .upload-zone {
            border: 1px dashed #111;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            margin-bottom: 1.5rem;
        }
        .upload-zone:hover { background: #f0f0f0; }
        input[type="file"] { display: none; }
        .file-list { list-style: none; margin-bottom: 1.5rem; }
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #eee;
            cursor: grab;
        }
        .file-item:active { cursor: grabbing; }
        .file-item.dragging { opacity: 0.4; }
        .remove-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
        }
        .remove-btn:hover { color: #c00; }
        .clear-btn {
            background: none;
            border: 1px solid #111;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-family: monospace;
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }
        .clear-btn:hover { background: #111; color: #fcfcfc; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .options { margin-bottom: 1.5rem; }
        .options label { display: block; margin-bottom: 0.5rem; }
        .options select, .options input[type="text"] {
            font-family: monospace;
            font-size: 1rem;
            padding: 0.5rem;
            border: 1px solid #111;
            background: #fcfcfc;
            width: 100%;
            max-width: 300px;
        }
        .hint { color: #666; font-size: 0.85rem; margin-top: 0.25rem; }
        .btn {
            background: #111;
            color: #fcfcfc;
            border: none;
            padding: 0.75rem 1.5rem;
            font-family: monospace;
            font-size: 1rem;
            cursor: pointer;
        }
        .btn:hover { background: #333; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        .progress { margin-top: 1.5rem; display: none; }
        .progress.active { display: block; }
        .progress-bar {
            height: 4px;
            background: #eee;
            margin-bottom: 0.5rem;
        }
        .progress-fill {
            height: 100%;
            background: #111;
            width: 0%;
            transition: width 0.2s;
        }
        .progress-text { color: #666; font-size: 0.85rem; }
        .output { margin-top: 2rem; padding-top: 2rem; border-top: 1px solid #111; display: none; }
        .output.active { display: block; }
        .output h2 { font-size: 1rem; margin-bottom: 1rem; }
        .download-link {
            color: #111;
            display: inline-block;
            margin-bottom: 0.5rem;
        }
        .download-list { list-style: none; margin-bottom: 1rem; }
        .download-list li { padding: 0.25rem 0; }
        .download-list a { color: #111; }
        .ocr-output {
            background: #f5f5f5;
            padding: 1rem;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 0.9rem;
            margin-top: 1rem;
        }
        .copy-btn {
            background: none;
            border: 1px solid #111;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            font-family: monospace;
            font-size: 0.85rem;
            margin-left: 1rem;
        }
        .copy-btn:hover { background: #111; color: #fcfcfc; }
        .pdf-info { color: #666; margin-bottom: 1rem; font-size: 0.9rem; }
        footer { margin-top: 3rem; color: #999; font-size: 0.85rem; }
    </style>
</head>
<body>
    <h1>Outils PDF</h1>
    <p class="sub">Traitement local dans votre navigateur</p>

    <div class="tabs">
        <span class="tab active" data-tab="merge">Fusionner</span>
        <span class="tab" data-tab="split">Diviser</span>
        <span class="tab" data-tab="extract">Extraire</span>
        <span class="tab" data-tab="ocr">OCR</span>
    </div>

    <div class="upload-zone" id="uploadZone">
        Déposez vos fichiers PDF ici ou cliquez pour parcourir
    </div>
    <input type="file" id="fileInput" accept=".pdf" multiple>

    <div id="fileListContainer" style="display: none;">
        <button class="clear-btn" id="clearBtn">Effacer tout</button>
        <ul class="file-list" id="fileList"></ul>
    </div>

    <div class="tab-content active" data-content="merge">
        <button class="btn" id="mergeBtn" disabled>Fusionner</button>
    </div>

    <div class="tab-content" data-content="split">
        <div id="splitInfo" class="pdf-info"></div>
        <div class="options">
            <label>
                Mode :
                <select id="splitMode">
                    <option value="single">Pages individuelles</option>
                    <option value="ranges">Plages personnalisées</option>
                </select>
            </label>
        </div>
        <div id="splitRangesInput" class="options" style="display: none;">
            <label>
                Plages :
                <input type="text" id="splitRanges" placeholder="1-3, 4-6, 7-10">
            </label>
            <p class="hint">Séparez les plages par des virgules</p>
        </div>
        <button class="btn" id="splitBtn" disabled>Diviser</button>
    </div>

    <div class="tab-content" data-content="extract">
        <div id="extractInfo" class="pdf-info"></div>
        <div class="options">
            <label>
                Pages :
                <input type="text" id="extractPages" placeholder="1, 3, 5-10">
            </label>
            <p class="hint">Virgules pour pages individuelles, tirets pour plages</p>
        </div>
        <button class="btn" id="extractBtn" disabled>Extraire</button>
    </div>

    <div class="tab-content" data-content="ocr">
        <div class="options">
            <label>
                Langue :
                <select id="ocrLang">
                    <option value="fra">Français</option>
                    <option value="eng">Anglais</option>
                </select>
            </label>
        </div>
        <button class="btn" id="ocrBtn" disabled>Extraire le texte</button>
    </div>

    <div class="progress" id="progressContainer">
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <p class="progress-text" id="progressText"></p>
    </div>

    <div class="output" id="outputSection">
        <h2 id="outputTitle"></h2>
        <div id="mergeOutput" style="display: none;">
            <a class="download-link" id="downloadLink" download="fusionne.pdf">↓ Télécharger le PDF fusionné</a>
        </div>
        <div id="ocrOutput" style="display: none;">
            <a class="download-link" id="downloadTextLink" download="texte.txt">↓ Télécharger le texte</a>
            <button class="copy-btn" id="copyBtn">Copier</button>
            <div class="ocr-output" id="ocrText"></div>
        </div>
        <div id="splitOutput" style="display: none;">
            <ul class="download-list" id="splitDownloadList"></ul>
            <button class="btn" id="downloadAllBtn">Télécharger en ZIP</button>
        </div>
        <div id="extractOutput" style="display: none;">
            <a class="download-link" id="extractDownloadLink" download="extrait.pdf">↓ Télécharger</a>
        </div>
    </div>

    <footer>Vos fichiers ne quittent jamais votre appareil.</footer>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = './vendor/pdf.worker.min.js';
        const tesseractConfig = {
            workerPath: './vendor/tesseract/worker.min.js',
            corePath: './vendor/tesseract/tesseract-core-simd.wasm.js',
            langPath: './vendor/tesseract/lang',
        };

        let files = [];
        let activeTab = 'merge';
        let splitResults = [];

        const $ = id => document.getElementById(id);
        const uploadZone = $('uploadZone');
        const fileInput = $('fileInput');
        const fileList = $('fileList');
        const fileListContainer = $('fileListContainer');
        const clearBtn = $('clearBtn');
        const mergeBtn = $('mergeBtn');
        const ocrBtn = $('ocrBtn');
        const splitBtn = $('splitBtn');
        const extractBtn = $('extractBtn');
        const splitMode = $('splitMode');
        const splitRangesInput = $('splitRangesInput');
        const splitRanges = $('splitRanges');
        const extractPages = $('extractPages');
        const splitInfo = $('splitInfo');
        const extractInfo = $('extractInfo');
        const progressContainer = $('progressContainer');
        const progressFill = $('progressFill');
        const progressText = $('progressText');
        const outputSection = $('outputSection');
        const outputTitle = $('outputTitle');
        const mergeOutput = $('mergeOutput');
        const ocrOutput = $('ocrOutput');
        const splitOutput = $('splitOutput');
        const extractOutput = $('extractOutput');
        const splitDownloadList = $('splitDownloadList');
        const downloadAllBtn = $('downloadAllBtn');
        const extractDownloadLink = $('extractDownloadLink');
        const downloadLink = $('downloadLink');
        const downloadTextLink = $('downloadTextLink');
        const ocrText = $('ocrText');
        const copyBtn = $('copyBtn');
        const ocrLang = $('ocrLang');
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                activeTab = tab.dataset.tab;
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                tabContents.forEach(c => c.classList.toggle('active', c.dataset.content === activeTab));
                updateButtons();
                updatePdfInfo();
            });
        });

        splitMode.addEventListener('change', () => {
            splitRangesInput.style.display = splitMode.value === 'ranges' ? 'block' : 'none';
        });

        uploadZone.addEventListener('click', () => fileInput.click());
        uploadZone.addEventListener('dragover', e => { e.preventDefault(); });
        uploadZone.addEventListener('drop', e => {
            e.preventDefault();
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', e => {
            handleFiles(e.target.files);
            fileInput.value = '';
        });

        clearBtn.addEventListener('click', () => {
            files = [];
            renderFileList();
            updateButtons();
            updatePdfInfo();
            outputSection.classList.remove('active');
        });

        function handleFiles(newFiles) {
            for (const file of newFiles) {
                if (file.type === 'application/pdf') files.push(file);
            }
            renderFileList();
            updateButtons();
            updatePdfInfo();
        }

        function renderFileList() {
            fileListContainer.style.display = files.length > 0 ? 'block' : 'none';
            fileList.innerHTML = files.map((file, i) => `
                <li class="file-item" draggable="true" data-index="${i}">
                    <span>${file.name} <small>(${formatSize(file.size)})</small></span>
                    <button class="remove-btn" data-index="${i}">×</button>
                </li>
            `).join('');

            fileList.querySelectorAll('.remove-btn').forEach(btn => {
                btn.addEventListener('click', e => {
                    files.splice(parseInt(e.target.dataset.index), 1);
                    renderFileList();
                    updateButtons();
                    updatePdfInfo();
                });
            });

            let draggedItem = null;
            fileList.querySelectorAll('.file-item').forEach(item => {
                item.addEventListener('dragstart', () => { draggedItem = item; item.classList.add('dragging'); });
                item.addEventListener('dragend', () => { item.classList.remove('dragging'); draggedItem = null; });
                item.addEventListener('dragover', e => {
                    e.preventDefault();
                    if (draggedItem && draggedItem !== item) {
                        const from = parseInt(draggedItem.dataset.index);
                        const to = parseInt(item.dataset.index);
                        const temp = files[from];
                        files.splice(from, 1);
                        files.splice(to, 0, temp);
                        renderFileList();
                    }
                });
            });
        }

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' o';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' Ko';
            return (bytes / (1024 * 1024)).toFixed(1) + ' Mo';
        }

        function updateButtons() {
            mergeBtn.disabled = files.length < 2;
            ocrBtn.disabled = files.length === 0;
            splitBtn.disabled = files.length !== 1;
            extractBtn.disabled = files.length !== 1;
        }

        async function updatePdfInfo() {
            if (files.length !== 1) {
                splitInfo.textContent = '';
                extractInfo.textContent = '';
                return;
            }
            try {
                const { PDFDocument } = PDFLib;
                const pdf = await PDFDocument.load(await files[0].arrayBuffer());
                const info = `${files[0].name} — ${pdf.getPageCount()} pages`;
                splitInfo.textContent = info;
                extractInfo.textContent = info;
            } catch (e) { console.error(e); }
        }

        function parsePageRanges(str, max) {
            const pages = new Set();
            str.split(',').map(s => s.trim()).filter(s => s).forEach(part => {
                if (part.includes('-')) {
                    const [a, b] = part.split('-').map(s => parseInt(s.trim()));
                    if (!isNaN(a) && !isNaN(b)) for (let i = Math.max(1, a); i <= Math.min(max, b); i++) pages.add(i - 1);
                } else {
                    const p = parseInt(part);
                    if (!isNaN(p) && p >= 1 && p <= max) pages.add(p - 1);
                }
            });
            return Array.from(pages).sort((a, b) => a - b);
        }

        function parseSplitRanges(str, max) {
            const ranges = [];
            str.split(',').map(s => s.trim()).filter(s => s).forEach(part => {
                const pages = [];
                if (part.includes('-')) {
                    const [a, b] = part.split('-').map(s => parseInt(s.trim()));
                    if (!isNaN(a) && !isNaN(b)) for (let i = Math.max(1, a); i <= Math.min(max, b); i++) pages.push(i - 1);
                } else {
                    const p = parseInt(part);
                    if (!isNaN(p) && p >= 1 && p <= max) pages.push(p - 1);
                }
                if (pages.length) ranges.push(pages);
            });
            return ranges;
        }

        function showProgress(text, pct) {
            progressContainer.classList.add('active');
            progressText.textContent = text;
            progressFill.style.width = pct + '%';
        }

        function hideProgress() {
            progressContainer.classList.remove('active');
            progressFill.style.width = '0%';
        }

        function hideAllOutputs() {
            mergeOutput.style.display = 'none';
            ocrOutput.style.display = 'none';
            splitOutput.style.display = 'none';
            extractOutput.style.display = 'none';
        }

        mergeBtn.addEventListener('click', async () => {
            if (files.length < 2) return;
            try {
                mergeBtn.disabled = true;
                showProgress('Fusion...', 0);
                const { PDFDocument } = PDFLib;
                const merged = await PDFDocument.create();
                for (let i = 0; i < files.length; i++) {
                    showProgress(`Fichier ${i + 1}/${files.length}`, (i / files.length) * 100);
                    const pdf = await PDFDocument.load(await files[i].arrayBuffer());
                    (await merged.copyPages(pdf, pdf.getPageIndices())).forEach(p => merged.addPage(p));
                }
                showProgress('Finalisation...', 90);
                const blob = new Blob([await merged.save()], { type: 'application/pdf' });
                downloadLink.href = URL.createObjectURL(blob);
                outputTitle.textContent = 'PDF fusionné';
                hideAllOutputs();
                mergeOutput.style.display = 'block';
                outputSection.classList.add('active');
                showProgress('Terminé', 100);
                setTimeout(hideProgress, 800);
            } catch (e) {
                alert('Erreur : ' + e.message);
                hideProgress();
            } finally {
                updateButtons();
            }
        });

        ocrBtn.addEventListener('click', async () => {
            if (files.length === 0) return;
            try {
                ocrBtn.disabled = true;
                showProgress('Initialisation OCR...', 0);
                const lang = ocrLang.value;
                let allText = '';
                for (let fi = 0; fi < files.length; fi++) {
                    const file = files[fi];
                    showProgress(`Chargement ${fi + 1}/${files.length}`, (fi / files.length) * 100);
                    const pdf = await pdfjsLib.getDocument({ data: await file.arrayBuffer() }).promise;
                    if (files.length > 1) allText += `\n${'='.repeat(40)}\n${file.name}\n${'='.repeat(40)}\n\n`;
                    for (let pn = 1; pn <= pdf.numPages; pn++) {
                        showProgress(`${file.name} — page ${pn}/${pdf.numPages}`, ((fi + pn / pdf.numPages) / files.length) * 100);
                        const page = await pdf.getPage(pn);
                        const vp = page.getViewport({ scale: 2 });
                        const canvas = document.createElement('canvas');
                        canvas.width = vp.width;
                        canvas.height = vp.height;
                        await page.render({ canvasContext: canvas.getContext('2d'), viewport: vp }).promise;
                        const result = await Tesseract.recognize(canvas, lang, { ...tesseractConfig });
                        if (pdf.numPages > 1) allText += `— Page ${pn} —\n\n`;
                        allText += result.data.text + '\n\n';
                    }
                }
                ocrText.textContent = allText.trim();
                downloadTextLink.href = URL.createObjectURL(new Blob([allText], { type: 'text/plain' }));
                outputTitle.textContent = 'Texte extrait';
                hideAllOutputs();
                ocrOutput.style.display = 'block';
                outputSection.classList.add('active');
                showProgress('Terminé', 100);
                setTimeout(hideProgress, 800);
            } catch (e) {
                alert('Erreur OCR : ' + e.message);
                hideProgress();
            } finally {
                updateButtons();
            }
        });

        copyBtn.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(ocrText.textContent);
                copyBtn.textContent = 'Copié !';
                setTimeout(() => copyBtn.textContent = 'Copier', 1500);
            } catch (e) { alert('Échec de la copie'); }
        });

        splitBtn.addEventListener('click', async () => {
            if (files.length !== 1) return;
            try {
                splitBtn.disabled = true;
                showProgress('Chargement...', 0);
                splitResults = [];
                const { PDFDocument } = PDFLib;
                const pdf = await PDFDocument.load(await files[0].arrayBuffer());
                const count = pdf.getPageCount();
                const base = files[0].name.replace(/\.pdf$/i, '');
                let sets = [];
                if (splitMode.value === 'single') {
                    for (let i = 0; i < count; i++) sets.push([i]);
                } else {
                    const r = splitRanges.value.trim();
                    if (!r) { alert('Entrez des plages'); hideProgress(); splitBtn.disabled = false; return; }
                    sets = parseSplitRanges(r, count);
                    if (!sets.length) { alert('Plages invalides'); hideProgress(); splitBtn.disabled = false; return; }
                }
                for (let i = 0; i < sets.length; i++) {
                    showProgress(`PDF ${i + 1}/${sets.length}`, (i / sets.length) * 100);
                    const newPdf = await PDFDocument.create();
                    (await newPdf.copyPages(pdf, sets[i])).forEach(p => newPdf.addPage(p));
                    const blob = new Blob([await newPdf.save()], { type: 'application/pdf' });
                    const s = sets[i][0] + 1, e = sets[i][sets[i].length - 1] + 1;
                    const name = s === e ? `${base}_p${s}.pdf` : `${base}_p${s}-${e}.pdf`;
                    splitResults.push({ url: URL.createObjectURL(blob), name, blob });
                }
                splitDownloadList.innerHTML = splitResults.map(r => `<li><a href="${r.url}" download="${r.name}">↓ ${r.name}</a></li>`).join('');
                outputTitle.textContent = `${splitResults.length} fichiers`;
                hideAllOutputs();
                splitOutput.style.display = 'block';
                outputSection.classList.add('active');
                showProgress('Terminé', 100);
                setTimeout(hideProgress, 800);
            } catch (e) {
                alert('Erreur : ' + e.message);
                hideProgress();
            } finally {
                updateButtons();
            }
        });

        downloadAllBtn.addEventListener('click', async () => {
            if (!splitResults.length) return;
            try {
                downloadAllBtn.disabled = true;
                showProgress('Création ZIP...', 0);
                const zip = new JSZip();
                for (let i = 0; i < splitResults.length; i++) {
                    showProgress(`Ajout ${i + 1}/${splitResults.length}`, (i / splitResults.length) * 80);
                    zip.file(splitResults[i].name, await splitResults[i].blob.arrayBuffer());
                }
                showProgress('Compression...', 90);
                const a = document.createElement('a');
                a.href = URL.createObjectURL(await zip.generateAsync({ type: 'blob' }));
                a.download = 'pdfs.zip';
                a.click();
                showProgress('Terminé', 100);
                setTimeout(hideProgress, 800);
            } catch (e) {
                alert('Erreur ZIP : ' + e.message);
                hideProgress();
            } finally {
                downloadAllBtn.disabled = false;
            }
        });

        extractBtn.addEventListener('click', async () => {
            if (files.length !== 1) return;
            const r = extractPages.value.trim();
            if (!r) { alert('Entrez les pages à extraire'); return; }
            try {
                extractBtn.disabled = true;
                showProgress('Chargement...', 0);
                const { PDFDocument } = PDFLib;
                const pdf = await PDFDocument.load(await files[0].arrayBuffer());
                const indices = parsePageRanges(r, pdf.getPageCount());
                if (!indices.length) { alert('Pages invalides'); hideProgress(); extractBtn.disabled = false; return; }
                showProgress(`Extraction de ${indices.length} page(s)...`, 30);
                const newPdf = await PDFDocument.create();
                (await newPdf.copyPages(pdf, indices)).forEach(p => newPdf.addPage(p));
                showProgress('Finalisation...', 80);
                const blob = new Blob([await newPdf.save()], { type: 'application/pdf' });
                extractDownloadLink.href = URL.createObjectURL(blob);
                extractDownloadLink.download = files[0].name.replace(/\.pdf$/i, '') + '_extrait.pdf';
                outputTitle.textContent = `${indices.length} page(s) extraite(s)`;
                hideAllOutputs();
                extractOutput.style.display = 'block';
                outputSection.classList.add('active');
                showProgress('Terminé', 100);
                setTimeout(hideProgress, 800);
            } catch (e) {
                alert('Erreur : ' + e.message);
                hideProgress();
            } finally {
                updateButtons();
            }
        });
    </script>
</body>
</html>
